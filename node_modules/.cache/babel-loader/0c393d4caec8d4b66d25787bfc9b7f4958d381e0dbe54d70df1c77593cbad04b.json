{"ast":null,"code":"// src/services/analyticsService.js\n\n/**\r\n * Analytics Service\r\n * \r\n * Handles tracking, analysis, and reporting of user interactions\r\n * and system performance metrics for the Socratic Debate Simulator.\r\n */\n\n// Local storage keys\nconst STORAGE_KEYS = {\n  USER_PREFERENCES: 'socratic_user_preferences',\n  INTERACTION_HISTORY: 'socratic_interaction_history',\n  SESSION_DATA: 'socratic_session_data'\n};\n\n/**\r\n * Initialize analytics service\r\n * @returns {boolean} Success status\r\n */\nexport const initAnalytics = () => {\n  try {\n    // Initialize session data if it doesn't exist\n    if (!getSessionData()) {\n      const sessionData = {\n        sessionId: generateSessionId(),\n        startTime: Date.now(),\n        deviceInfo: getDeviceInfo(),\n        interactionCount: 0,\n        debatesStarted: 0,\n        topicsExplored: [],\n        expertInteractions: {}\n      };\n      saveSessionData(sessionData);\n    }\n\n    // Log initialization\n    console.log('Analytics service initialized');\n    return true;\n  } catch (error) {\n    console.error('Failed to initialize analytics service:', error);\n    return false;\n  }\n};\n\n/**\r\n * Track debate initiation\r\n * @param {string} topicId - Topic identifier\r\n * @param {string} debateId - Debate identifier\r\n * @param {Array} expertIds - Selected expert IDs\r\n * @param {string} format - Debate format (standard, oxford, socratic)\r\n */\nexport const trackDebateStart = (topicId, debateId, expertIds, format) => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return;\n\n    // Update session data\n    sessionData.debatesStarted += 1;\n\n    // Track new topic if not previously explored\n    if (!sessionData.topicsExplored.includes(topicId)) {\n      sessionData.topicsExplored.push(topicId);\n    }\n\n    // Initialize expert interaction counters\n    expertIds.forEach(expertId => {\n      if (!sessionData.expertInteractions[expertId]) {\n        sessionData.expertInteractions[expertId] = 0;\n      }\n    });\n\n    // Save updated session data\n    saveSessionData(sessionData);\n\n    // Log debate event\n    logEvent('debate_started', {\n      topicId,\n      debateId,\n      expertIds,\n      format,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track debate start:', error);\n  }\n};\n\n/**\r\n * Track user interaction with experts\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} expertId - Expert identifier\r\n * @param {string} interactionType - Type of interaction (question, challenge, etc.)\r\n */\nexport const trackExpertInteraction = (debateId, expertId, interactionType) => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return;\n\n    // Update interaction counts\n    sessionData.interactionCount += 1;\n\n    // Update expert-specific interaction count\n    if (sessionData.expertInteractions[expertId] !== undefined) {\n      sessionData.expertInteractions[expertId] += 1;\n    } else {\n      sessionData.expertInteractions[expertId] = 1;\n    }\n\n    // Save updated session data\n    saveSessionData(sessionData);\n\n    // Log interaction event\n    logEvent('expert_interaction', {\n      debateId,\n      expertId,\n      interactionType,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track expert interaction:', error);\n  }\n};\n\n/**\r\n * Track citation exploration\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} citationId - Citation identifier\r\n * @param {string} expertId - Expert who provided the citation\r\n */\nexport const trackCitationExplored = (debateId, citationId, expertId) => {\n  try {\n    // Log citation event\n    logEvent('citation_explored', {\n      debateId,\n      citationId,\n      expertId,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track citation exploration:', error);\n  }\n};\n\n/**\r\n * Track user preference settings\r\n * @param {Object} preferences - User preference settings\r\n */\nexport const trackUserPreferences = preferences => {\n  try {\n    // Save preferences\n    saveUserPreferences(preferences);\n\n    // Log preferences event\n    logEvent('preferences_updated', {\n      preferences,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track user preferences:', error);\n  }\n};\n\n/**\r\n * Track debate completion\r\n * @param {string} debateId - Debate identifier\r\n * @param {number} duration - Debate duration in seconds\r\n * @param {number} interactionCount - Number of user interactions\r\n */\nexport const trackDebateCompletion = (debateId, duration, interactionCount) => {\n  try {\n    // Log completion event\n    logEvent('debate_completed', {\n      debateId,\n      duration,\n      interactionCount,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track debate completion:', error);\n  }\n};\n\n/**\r\n * Generate learning insights from debate interaction\r\n * @param {string} debateId - Debate identifier\r\n * @returns {Object} Learning insights data\r\n */\nexport const generateLearningInsights = debateId => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return null;\n\n    // Get interaction history\n    const interactionHistory = getInteractionHistory();\n\n    // Filter interactions for this debate\n    const debateInteractions = interactionHistory.filter(event => event.data.debateId === debateId);\n\n    // Analyze interaction patterns\n    const expertInteractions = {};\n    const interactionTypes = {};\n    debateInteractions.forEach(event => {\n      if (event.type === 'expert_interaction') {\n        const {\n          expertId,\n          interactionType\n        } = event.data;\n\n        // Count expert interactions\n        expertInteractions[expertId] = (expertInteractions[expertId] || 0) + 1;\n\n        // Count interaction types\n        interactionTypes[interactionType] = (interactionTypes[interactionType] || 0) + 1;\n      }\n    });\n\n    // Generate insights\n    return {\n      totalInteractions: debateInteractions.length,\n      expertEngagement: expertInteractions,\n      interactionTypes,\n      topInteractionType: getTopKey(interactionTypes),\n      mostEngagedExpert: getTopKey(expertInteractions),\n      learningStyle: determineLearningStyle(interactionTypes)\n    };\n  } catch (error) {\n    console.error('Failed to generate learning insights:', error);\n    return null;\n  }\n};\n\n/**\r\n * Save user preferences to local storage\r\n * @param {Object} preferences - User preference settings\r\n */\nconst saveUserPreferences = preferences => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.USER_PREFERENCES, JSON.stringify(preferences));\n  } catch (error) {\n    console.error('Failed to save user preferences:', error);\n  }\n};\n\n/**\r\n * Get user preferences from local storage\r\n * @returns {Object|null} User preferences or null if not found\r\n */\nexport const getUserPreferences = () => {\n  try {\n    const preferences = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);\n    return preferences ? JSON.parse(preferences) : null;\n  } catch (error) {\n    console.error('Failed to get user preferences:', error);\n    return null;\n  }\n};\n\n/**\r\n * Save session data to local storage\r\n * @param {Object} sessionData - Current session data\r\n */\nconst saveSessionData = sessionData => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.SESSION_DATA, JSON.stringify(sessionData));\n  } catch (error) {\n    console.error('Failed to save session data:', error);\n  }\n};\n\n/**\r\n * Get session data from local storage\r\n * @returns {Object|null} Session data or null if not found\r\n */\nconst getSessionData = () => {\n  try {\n    const sessionData = localStorage.getItem(STORAGE_KEYS.SESSION_DATA);\n    return sessionData ? JSON.parse(sessionData) : null;\n  } catch (error) {\n    console.error('Failed to get session data:', error);\n    return null;\n  }\n};\n\n/**\r\n * Log event to interaction history\r\n * @param {string} type - Event type\r\n * @param {Object} data - Event data\r\n */\nconst logEvent = (type, data) => {\n  try {\n    // Get existing history\n    const history = getInteractionHistory();\n\n    // Add new event\n    history.push({\n      type,\n      data,\n      timestamp: Date.now()\n    });\n\n    // Limit history size (keep last 1000 events)\n    if (history.length > 1000) {\n      history.shift();\n    }\n\n    // Save updated history\n    localStorage.setItem(STORAGE_KEYS.INTERACTION_HISTORY, JSON.stringify(history));\n  } catch (error) {\n    console.error('Failed to log event:', error);\n  }\n};\n\n/**\r\n * Get interaction history from local storage\r\n * @returns {Array} Interaction event history\r\n */\nconst getInteractionHistory = () => {\n  try {\n    const history = localStorage.getItem(STORAGE_KEYS.INTERACTION_HISTORY);\n    return history ? JSON.parse(history) : [];\n  } catch (error) {\n    console.error('Failed to get interaction history:', error);\n    return [];\n  }\n};\n\n/**\r\n * Generate unique session ID\r\n * @returns {string} Session identifier\r\n */\nconst generateSessionId = () => {\n  return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);\n};\n\n/**\r\n * Get device information\r\n * @returns {Object} Device information\r\n */\nconst getDeviceInfo = () => {\n  return {\n    userAgent: navigator.userAgent,\n    language: navigator.language,\n    platform: navigator.platform,\n    screenWidth: window.screen.width,\n    screenHeight: window.screen.height\n  };\n};\n\n/**\r\n * Get key with highest value from object\r\n * @param {Object} obj - Object with numeric values\r\n * @returns {string|null} Key with highest value or null if empty\r\n */\nconst getTopKey = obj => {\n  if (!obj || Object.keys(obj).length === 0) return null;\n  return Object.entries(obj).reduce((top, [key, value]) => value > top.value ? {\n    key,\n    value\n  } : top, {\n    key: Object.keys(obj)[0],\n    value: obj[Object.keys(obj)[0]]\n  }).key;\n};\n\n/**\r\n * Determine user learning style based on interaction patterns\r\n * @param {Object} interactionTypes - Counts of different interaction types\r\n * @returns {string} Learning style descriptor\r\n */\nconst determineLearningStyle = interactionTypes => {\n  // Count different categories of interactions\n  const questionCount = interactionTypes.question || 0;\n  const challengeCount = interactionTypes.challenge || 0;\n  const evidenceCount = interactionTypes.evidence || 0;\n\n  // Determine primary learning style\n  if (questionCount > challengeCount && questionCount > evidenceCount) {\n    return 'Inquisitive Explorer';\n  } else if (challengeCount > questionCount && challengeCount > evidenceCount) {\n    return 'Critical Thinker';\n  } else if (evidenceCount > questionCount && evidenceCount > challengeCount) {\n    return 'Evidence-Based Analyzer';\n  } else {\n    return 'Balanced Learner';\n  }\n};\n\n/**\r\n * Clear all analytics data\r\n * @returns {boolean} Success status\r\n */\nexport const clearAnalyticsData = () => {\n  try {\n    localStorage.removeItem(STORAGE_KEYS.USER_PREFERENCES);\n    localStorage.removeItem(STORAGE_KEYS.INTERACTION_HISTORY);\n    localStorage.removeItem(STORAGE_KEYS.SESSION_DATA);\n    return true;\n  } catch (error) {\n    console.error('Failed to clear analytics data:', error);\n    return false;\n  }\n};\nexport default {\n  initAnalytics,\n  trackDebateStart,\n  trackExpertInteraction,\n  trackCitationExplored,\n  trackUserPreferences,\n  trackDebateCompletion,\n  generateLearningInsights,\n  getUserPreferences,\n  clearAnalyticsData,\n  saveUserPreferences\n};","map":{"version":3,"names":["STORAGE_KEYS","USER_PREFERENCES","INTERACTION_HISTORY","SESSION_DATA","initAnalytics","getSessionData","sessionData","sessionId","generateSessionId","startTime","Date","now","deviceInfo","getDeviceInfo","interactionCount","debatesStarted","topicsExplored","expertInteractions","saveSessionData","console","log","error","trackDebateStart","topicId","debateId","expertIds","format","includes","push","forEach","expertId","logEvent","timestamp","trackExpertInteraction","interactionType","undefined","trackCitationExplored","citationId","trackUserPreferences","preferences","saveUserPreferences","trackDebateCompletion","duration","generateLearningInsights","interactionHistory","getInteractionHistory","debateInteractions","filter","event","data","interactionTypes","type","totalInteractions","length","expertEngagement","topInteractionType","getTopKey","mostEngagedExpert","learningStyle","determineLearningStyle","localStorage","setItem","JSON","stringify","getUserPreferences","getItem","parse","history","shift","Math","random","toString","substring","userAgent","navigator","language","platform","screenWidth","window","screen","width","screenHeight","height","obj","Object","keys","entries","reduce","top","key","value","questionCount","question","challengeCount","challenge","evidenceCount","evidence","clearAnalyticsData","removeItem"],"sources":["C:/Users/HAJAR/socratic-debate-simulator/src/services/analyticsService.js"],"sourcesContent":["// src/services/analyticsService.js\r\n\r\n/**\r\n * Analytics Service\r\n * \r\n * Handles tracking, analysis, and reporting of user interactions\r\n * and system performance metrics for the Socratic Debate Simulator.\r\n */\r\n\r\n// Local storage keys\r\nconst STORAGE_KEYS = {\r\n  USER_PREFERENCES: 'socratic_user_preferences',\r\n  INTERACTION_HISTORY: 'socratic_interaction_history',\r\n  SESSION_DATA: 'socratic_session_data',\r\n};\r\n\r\n/**\r\n * Initialize analytics service\r\n * @returns {boolean} Success status\r\n */\r\nexport const initAnalytics = () => {\r\n  try {\r\n    // Initialize session data if it doesn't exist\r\n    if (!getSessionData()) {\r\n      const sessionData = {\r\n        sessionId: generateSessionId(),\r\n        startTime: Date.now(),\r\n        deviceInfo: getDeviceInfo(),\r\n        interactionCount: 0,\r\n        debatesStarted: 0,\r\n        topicsExplored: [],\r\n        expertInteractions: {},\r\n      };\r\n      \r\n      saveSessionData(sessionData);\r\n    }\r\n    \r\n    // Log initialization\r\n    console.log('Analytics service initialized');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Failed to initialize analytics service:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Track debate initiation\r\n * @param {string} topicId - Topic identifier\r\n * @param {string} debateId - Debate identifier\r\n * @param {Array} expertIds - Selected expert IDs\r\n * @param {string} format - Debate format (standard, oxford, socratic)\r\n */\r\nexport const trackDebateStart = (topicId, debateId, expertIds, format) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return;\r\n    \r\n    // Update session data\r\n    sessionData.debatesStarted += 1;\r\n    \r\n    // Track new topic if not previously explored\r\n    if (!sessionData.topicsExplored.includes(topicId)) {\r\n      sessionData.topicsExplored.push(topicId);\r\n    }\r\n    \r\n    // Initialize expert interaction counters\r\n    expertIds.forEach(expertId => {\r\n      if (!sessionData.expertInteractions[expertId]) {\r\n        sessionData.expertInteractions[expertId] = 0;\r\n      }\r\n    });\r\n    \r\n    // Save updated session data\r\n    saveSessionData(sessionData);\r\n    \r\n    // Log debate event\r\n    logEvent('debate_started', {\r\n      topicId,\r\n      debateId,\r\n      expertIds,\r\n      format,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track debate start:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track user interaction with experts\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} expertId - Expert identifier\r\n * @param {string} interactionType - Type of interaction (question, challenge, etc.)\r\n */\r\nexport const trackExpertInteraction = (debateId, expertId, interactionType) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return;\r\n    \r\n    // Update interaction counts\r\n    sessionData.interactionCount += 1;\r\n    \r\n    // Update expert-specific interaction count\r\n    if (sessionData.expertInteractions[expertId] !== undefined) {\r\n      sessionData.expertInteractions[expertId] += 1;\r\n    } else {\r\n      sessionData.expertInteractions[expertId] = 1;\r\n    }\r\n    \r\n    // Save updated session data\r\n    saveSessionData(sessionData);\r\n    \r\n    // Log interaction event\r\n    logEvent('expert_interaction', {\r\n      debateId,\r\n      expertId,\r\n      interactionType,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track expert interaction:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track citation exploration\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} citationId - Citation identifier\r\n * @param {string} expertId - Expert who provided the citation\r\n */\r\nexport const trackCitationExplored = (debateId, citationId, expertId) => {\r\n  try {\r\n    // Log citation event\r\n    logEvent('citation_explored', {\r\n      debateId,\r\n      citationId,\r\n      expertId,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track citation exploration:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track user preference settings\r\n * @param {Object} preferences - User preference settings\r\n */\r\nexport const trackUserPreferences = (preferences) => {\r\n  try {\r\n    // Save preferences\r\n    saveUserPreferences(preferences);\r\n    \r\n    // Log preferences event\r\n    logEvent('preferences_updated', {\r\n      preferences,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track user preferences:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track debate completion\r\n * @param {string} debateId - Debate identifier\r\n * @param {number} duration - Debate duration in seconds\r\n * @param {number} interactionCount - Number of user interactions\r\n */\r\nexport const trackDebateCompletion = (debateId, duration, interactionCount) => {\r\n  try {\r\n    // Log completion event\r\n    logEvent('debate_completed', {\r\n      debateId,\r\n      duration,\r\n      interactionCount,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track debate completion:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Generate learning insights from debate interaction\r\n * @param {string} debateId - Debate identifier\r\n * @returns {Object} Learning insights data\r\n */\r\nexport const generateLearningInsights = (debateId) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return null;\r\n    \r\n    // Get interaction history\r\n    const interactionHistory = getInteractionHistory();\r\n    \r\n    // Filter interactions for this debate\r\n    const debateInteractions = interactionHistory.filter(\r\n      event => event.data.debateId === debateId\r\n    );\r\n    \r\n    // Analyze interaction patterns\r\n    const expertInteractions = {};\r\n    const interactionTypes = {};\r\n    \r\n    debateInteractions.forEach(event => {\r\n      if (event.type === 'expert_interaction') {\r\n        const { expertId, interactionType } = event.data;\r\n        \r\n        // Count expert interactions\r\n        expertInteractions[expertId] = (expertInteractions[expertId] || 0) + 1;\r\n        \r\n        // Count interaction types\r\n        interactionTypes[interactionType] = (interactionTypes[interactionType] || 0) + 1;\r\n      }\r\n    });\r\n    \r\n    // Generate insights\r\n    return {\r\n      totalInteractions: debateInteractions.length,\r\n      expertEngagement: expertInteractions,\r\n      interactionTypes,\r\n      topInteractionType: getTopKey(interactionTypes),\r\n      mostEngagedExpert: getTopKey(expertInteractions),\r\n      learningStyle: determineLearningStyle(interactionTypes),\r\n    };\r\n  } catch (error) {\r\n    console.error('Failed to generate learning insights:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Save user preferences to local storage\r\n * @param {Object} preferences - User preference settings\r\n */\r\nconst saveUserPreferences = (preferences) => {\r\n  try {\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.USER_PREFERENCES,\r\n      JSON.stringify(preferences)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to save user preferences:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get user preferences from local storage\r\n * @returns {Object|null} User preferences or null if not found\r\n */\r\nexport const getUserPreferences = () => {\r\n  try {\r\n    const preferences = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);\r\n    return preferences ? JSON.parse(preferences) : null;\r\n  } catch (error) {\r\n    console.error('Failed to get user preferences:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Save session data to local storage\r\n * @param {Object} sessionData - Current session data\r\n */\r\nconst saveSessionData = (sessionData) => {\r\n  try {\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.SESSION_DATA,\r\n      JSON.stringify(sessionData)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to save session data:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get session data from local storage\r\n * @returns {Object|null} Session data or null if not found\r\n */\r\nconst getSessionData = () => {\r\n  try {\r\n    const sessionData = localStorage.getItem(STORAGE_KEYS.SESSION_DATA);\r\n    return sessionData ? JSON.parse(sessionData) : null;\r\n  } catch (error) {\r\n    console.error('Failed to get session data:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Log event to interaction history\r\n * @param {string} type - Event type\r\n * @param {Object} data - Event data\r\n */\r\nconst logEvent = (type, data) => {\r\n  try {\r\n    // Get existing history\r\n    const history = getInteractionHistory();\r\n    \r\n    // Add new event\r\n    history.push({\r\n      type,\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n    \r\n    // Limit history size (keep last 1000 events)\r\n    if (history.length > 1000) {\r\n      history.shift();\r\n    }\r\n    \r\n    // Save updated history\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.INTERACTION_HISTORY,\r\n      JSON.stringify(history)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to log event:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get interaction history from local storage\r\n * @returns {Array} Interaction event history\r\n */\r\nconst getInteractionHistory = () => {\r\n  try {\r\n    const history = localStorage.getItem(STORAGE_KEYS.INTERACTION_HISTORY);\r\n    return history ? JSON.parse(history) : [];\r\n  } catch (error) {\r\n    console.error('Failed to get interaction history:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Generate unique session ID\r\n * @returns {string} Session identifier\r\n */\r\nconst generateSessionId = () => {\r\n  return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);\r\n};\r\n\r\n/**\r\n * Get device information\r\n * @returns {Object} Device information\r\n */\r\nconst getDeviceInfo = () => {\r\n  return {\r\n    userAgent: navigator.userAgent,\r\n    language: navigator.language,\r\n    platform: navigator.platform,\r\n    screenWidth: window.screen.width,\r\n    screenHeight: window.screen.height,\r\n  };\r\n};\r\n\r\n/**\r\n * Get key with highest value from object\r\n * @param {Object} obj - Object with numeric values\r\n * @returns {string|null} Key with highest value or null if empty\r\n */\r\nconst getTopKey = (obj) => {\r\n  if (!obj || Object.keys(obj).length === 0) return null;\r\n  \r\n  return Object.entries(obj).reduce(\r\n    (top, [key, value]) => (value > top.value ? { key, value } : top),\r\n    { key: Object.keys(obj)[0], value: obj[Object.keys(obj)[0]] }\r\n  ).key;\r\n};\r\n\r\n/**\r\n * Determine user learning style based on interaction patterns\r\n * @param {Object} interactionTypes - Counts of different interaction types\r\n * @returns {string} Learning style descriptor\r\n */\r\nconst determineLearningStyle = (interactionTypes) => {\r\n  // Count different categories of interactions\r\n  const questionCount = interactionTypes.question || 0;\r\n  const challengeCount = interactionTypes.challenge || 0;\r\n  const evidenceCount = interactionTypes.evidence || 0;\r\n  \r\n  // Determine primary learning style\r\n  if (questionCount > challengeCount && questionCount > evidenceCount) {\r\n    return 'Inquisitive Explorer';\r\n  } else if (challengeCount > questionCount && challengeCount > evidenceCount) {\r\n    return 'Critical Thinker';\r\n  } else if (evidenceCount > questionCount && evidenceCount > challengeCount) {\r\n    return 'Evidence-Based Analyzer';\r\n  } else {\r\n    return 'Balanced Learner';\r\n  }\r\n};\r\n\r\n/**\r\n * Clear all analytics data\r\n * @returns {boolean} Success status\r\n */\r\nexport const clearAnalyticsData = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEYS.USER_PREFERENCES);\r\n    localStorage.removeItem(STORAGE_KEYS.INTERACTION_HISTORY);\r\n    localStorage.removeItem(STORAGE_KEYS.SESSION_DATA);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Failed to clear analytics data:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport default {\r\n  initAnalytics,\r\n  trackDebateStart,\r\n  trackExpertInteraction,\r\n  trackCitationExplored,\r\n  trackUserPreferences,\r\n  trackDebateCompletion,\r\n  generateLearningInsights,\r\n  getUserPreferences,\r\n  clearAnalyticsData,\r\n  saveUserPreferences\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}