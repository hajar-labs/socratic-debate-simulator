{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\HAJAR\\\\socratic-debate-simulator\\\\src\\\\contexts\\\\DebateContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/contexts/DebateContext.js\n\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport * as debateService from '../services/debateService';\nimport analyticsService from '../services/analyticsService';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DebateContext = /*#__PURE__*/createContext();\n\n// Custom hook for using the debate context\nexport const useDebate = () => {\n  _s();\n  const context = useContext(DebateContext);\n  if (!context) {\n    throw new Error('useDebate must be used within a DebateProvider');\n  }\n  return context;\n};\n\n// Context provider component\n_s(useDebate, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const DebateProvider = ({\n  children\n}) => {\n  _s2();\n  // Debate state\n  const [debateId, setDebateId] = useState(null);\n  const [topic, setTopic] = useState('');\n  const [format, setFormat] = useState('standard');\n  const [selectedExperts, setSelectedExperts] = useState([]);\n  const [transcript, setTranscript] = useState([]);\n  const [argumentMap, setArgumentMap] = useState({\n    nodes: [],\n    edges: []\n  });\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // UI state\n  const [activeExpertId, setActiveExpertId] = useState(null);\n  const [activeCitation, setActiveCitation] = useState(null);\n  const [selectedArgument, setSelectedArgument] = useState(null);\n  const [debateControls, setDebateControls] = useState({\n    depth: 50,\n    // 0-100 scale\n    technicalLevel: 'medium',\n    // basic, medium, advanced\n    emphasis: 'balanced' // ethical, practical, theoretical, balanced\n  });\n\n  // Initialize analytics when component mounts\n  useEffect(() => {\n    analyticsService.initAnalytics();\n  }, []);\n\n  /**\r\n   * Start a new debate\r\n   */\n  const startDebate = useCallback(async (newTopic, experts, debateFormat = 'standard') => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Generate a new debate\n      const result = await debateService.generateDebate(newTopic, experts, debateFormat);\n\n      // Update state with new debate data\n      setDebateId(result.debateId);\n      setTopic(newTopic);\n      setFormat(debateFormat);\n      setSelectedExperts(experts);\n      setTranscript(result.transcript || []);\n      setArgumentMap(result.argumentMap || {\n        nodes: [],\n        edges: []\n      });\n\n      // Set the first expert as active\n      if (result.transcript && result.transcript.length > 0) {\n        setActiveExpertId(result.transcript[0].expertId);\n      }\n\n      // Track debate start in analytics\n      analyticsService.trackDebateStart(newTopic, result.debateId, experts, debateFormat);\n      return result;\n    } catch (err) {\n      setError('Failed to start debate: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  /**\r\n   * Ask a follow-up question to a specific expert\r\n   */\n  const askFollowUp = useCallback(async (expertId, question) => {\n    if (!debateId) return null;\n    setLoading(true);\n    setError(null);\n    try {\n      // Send the follow-up question\n      const response = await debateService.askFollowUpQuestion(debateId, expertId, question);\n\n      // Update transcript with the response\n      setTranscript(prev => [...prev, response]);\n      setActiveExpertId(expertId);\n\n      // Track the interaction\n      analyticsService.trackExpertInteraction(debateId, expertId, 'question');\n      return response;\n    } catch (err) {\n      setError('Failed to ask follow-up: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [debateId]);\n\n  /**\r\n   * Challenge an assumption made by an expert\r\n   */\n  const challengeAssumption = useCallback(async (argumentId, challenge) => {\n    if (!debateId) return null;\n    setLoading(true);\n    setError(null);\n    try {\n      // Send the challenge\n      const result = await debateService.challengeAssumption(debateId, argumentId, challenge);\n\n      // Update transcript with responses\n      if (result.responses) {\n        setTranscript(prev => [...prev, ...result.responses]);\n      }\n\n      // Update argument map if provided\n      if (result.updatedArgumentMap) {\n        setArgumentMap(result.updatedArgumentMap);\n      }\n\n      // Track the interaction with the first responding expert\n      if (result.responses && result.responses.length > 0) {\n        analyticsService.trackExpertInteraction(debateId, result.responses[0].expertId, 'challenge');\n      }\n      return result;\n    } catch (err) {\n      setError('Failed to challenge assumption: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [debateId]);\n\n  /**\r\n   * Request evidence for a specific claim\r\n   */\n  const requestEvidence = useCallback(async argumentId => {\n    if (!debateId) return null;\n    setLoading(true);\n    setError(null);\n    try {\n      // Request evidence\n      const result = await debateService.requestEvidence(debateId, argumentId);\n\n      // Set active citation to show evidence\n      setActiveCitation(result);\n\n      // Find which expert made this argument\n      const expertId = findExpertForArgument(argumentId);\n      if (expertId) {\n        analyticsService.trackExpertInteraction(debateId, expertId, 'evidence');\n      }\n      return result;\n    } catch (err) {\n      setError('Failed to request evidence: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [debateId]);\n\n  /**\r\n   * Find which expert is associated with a given argument\r\n   */\n  const findExpertForArgument = useCallback(argumentId => {\n    // Find the node in the argument map\n    const node = argumentMap.nodes.find(n => n.id === argumentId);\n    return node ? node.expertId : null;\n  }, [argumentMap]);\n\n  /**\r\n   * Generate a steelman version of an argument\r\n   */\n  const generateSteelmanArgument = useCallback(async argumentId => {\n    if (!debateId) return null;\n    setLoading(true);\n    setError(null);\n    try {\n      // Request a steelman version\n      const result = await debateService.generateSteelmanArgument(debateId, argumentId);\n\n      // Create a new message for the steelman response\n      const expertId = findExpertForArgument(argumentId);\n      if (expertId) {\n        const steelmanMessage = {\n          expertId,\n          content: `Let me strengthen that argument: ${result.steelmanVersion}`,\n          timestamp: Date.now(),\n          citations: result.additionalEvidence || [],\n          isRefinement: true\n        };\n\n        // Add to transcript\n        setTranscript(prev => [...prev, steelmanMessage]);\n\n        // Track the interaction\n        analyticsService.trackExpertInteraction(debateId, expertId, 'steelman');\n      }\n      return result;\n    } catch (err) {\n      setError('Failed to generate steelman argument: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [debateId, findExpertForArgument]);\n\n  /**\r\n   * Introduce a new consideration to the debate\r\n   */\n  const introduceNewConsideration = useCallback(async consideration => {\n    if (!debateId) return null;\n    setLoading(true);\n    setError(null);\n    try {\n      // Introduce the new consideration\n      const result = await debateService.introduceNewConsideration(debateId, consideration);\n\n      // Update transcript with responses\n      if (result.responses) {\n        setTranscript(prev => [...prev, ...result.responses]);\n      }\n\n      // Update argument map if provided\n      if (result.updatedArgumentMap) {\n        setArgumentMap(result.updatedArgumentMap);\n      }\n\n      // Track the interaction with all responding experts\n      if (result.responses && result.responses.length > 0) {\n        result.responses.forEach(response => {\n          analyticsService.trackExpertInteraction(debateId, response.expertId, 'consideration');\n        });\n      }\n      return result;\n    } catch (err) {\n      setError('Failed to introduce new consideration: ' + err.message);\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  }, [debateId]);\n\n  /**\r\n   * Update debate control parameters\r\n   */\n  const updateDebateControls = useCallback(controls => {\n    setDebateControls(prev => ({\n      ...prev,\n      ...controls\n    }));\n\n    // Track preference updates\n    analyticsService.trackUserPreferences({\n      debateControls: {\n        ...debateControls,\n        ...controls\n      }\n    });\n  }, [debateControls]);\n\n  /**\r\n   * View a specific citation\r\n   */\n  const viewCitation = useCallback((citationId, expertId) => {\n    // Find the citation in the transcript\n    const citation = transcript.flatMap(message => message.citations || []).find(cite => cite.id === citationId);\n\n    // Set as active citation\n    if (citation) {\n      setActiveCitation(citation);\n\n      // Track citation exploration\n      analyticsService.trackCitationExplored(debateId, citationId, expertId);\n    }\n  }, [transcript, debateId]);\n\n  /**\r\n   * Clear active citation\r\n   */\n  const clearActiveCitation = useCallback(() => {\n    setActiveCitation(null);\n  }, []);\n\n  /**\r\n   * Select an argument in the visualization\r\n   */\n  const selectArgument = useCallback(argumentId => {\n    setSelectedArgument(argumentId);\n  }, []);\n\n  /**\r\n   * Reset the debate state\r\n   */\n  const resetDebate = useCallback(() => {\n    // Track debate completion if there was an active debate\n    if (debateId) {\n      var _transcript$;\n      const duration = Math.floor((Date.now() - ((_transcript$ = transcript[0]) === null || _transcript$ === void 0 ? void 0 : _transcript$.timestamp) || 0) / 1000);\n      analyticsService.trackDebateCompletion(debateId, duration, transcript.length);\n    }\n\n    // Reset all state\n    setDebateId(null);\n    setTopic('');\n    setFormat('standard');\n    setSelectedExperts([]);\n    setTranscript([]);\n    setArgumentMap({\n      nodes: [],\n      edges: []\n    });\n    setActiveExpertId(null);\n    setActiveCitation(null);\n    setSelectedArgument(null);\n    setError(null);\n  }, [debateId, transcript]);\n\n  // Context value\n  const contextValue = {\n    // State\n    debateId,\n    topic,\n    format,\n    selectedExperts,\n    transcript,\n    argumentMap,\n    loading,\n    error,\n    activeExpertId,\n    activeCitation,\n    selectedArgument,\n    debateControls,\n    // Actions\n    startDebate,\n    askFollowUp,\n    challengeAssumption,\n    requestEvidence,\n    generateSteelmanArgument,\n    introduceNewConsideration,\n    updateDebateControls,\n    viewCitation,\n    clearActiveCitation,\n    selectArgument,\n    resetDebate\n  };\n  return /*#__PURE__*/_jsxDEV(DebateContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 373,\n    columnNumber: 5\n  }, this);\n};\n_s2(DebateProvider, \"1cmDXT+QpIceVsZfoMYnFS9zWhk=\");\n_c = DebateProvider;\nexport default DebateContext;\nvar _c;\n$RefreshReg$(_c, \"DebateProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","debateService","analyticsService","jsxDEV","_jsxDEV","DebateContext","useDebate","_s","context","Error","DebateProvider","children","_s2","debateId","setDebateId","topic","setTopic","format","setFormat","selectedExperts","setSelectedExperts","transcript","setTranscript","argumentMap","setArgumentMap","nodes","edges","loading","setLoading","error","setError","activeExpertId","setActiveExpertId","activeCitation","setActiveCitation","selectedArgument","setSelectedArgument","debateControls","setDebateControls","depth","technicalLevel","emphasis","initAnalytics","startDebate","newTopic","experts","debateFormat","result","generateDebate","length","expertId","trackDebateStart","err","message","askFollowUp","question","response","askFollowUpQuestion","prev","trackExpertInteraction","challengeAssumption","argumentId","challenge","responses","updatedArgumentMap","requestEvidence","findExpertForArgument","node","find","n","id","generateSteelmanArgument","steelmanMessage","content","steelmanVersion","timestamp","Date","now","citations","additionalEvidence","isRefinement","introduceNewConsideration","consideration","forEach","updateDebateControls","controls","trackUserPreferences","viewCitation","citationId","citation","flatMap","cite","trackCitationExplored","clearActiveCitation","selectArgument","resetDebate","_transcript$","duration","Math","floor","trackDebateCompletion","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/HAJAR/socratic-debate-simulator/src/contexts/DebateContext.js"],"sourcesContent":["// src/contexts/DebateContext.js\r\n\r\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\r\nimport * as debateService from '../services/debateService';\r\nimport analyticsService from '../services/analyticsService';\r\n\r\n// Create context\r\nconst DebateContext = createContext();\r\n\r\n// Custom hook for using the debate context\r\nexport const useDebate = () => {\r\n  const context = useContext(DebateContext);\r\n  if (!context) {\r\n    throw new Error('useDebate must be used within a DebateProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\n// Context provider component\r\nexport const DebateProvider = ({ children }) => {\r\n  // Debate state\r\n  const [debateId, setDebateId] = useState(null);\r\n  const [topic, setTopic] = useState('');\r\n  const [format, setFormat] = useState('standard');\r\n  const [selectedExperts, setSelectedExperts] = useState([]);\r\n  const [transcript, setTranscript] = useState([]);\r\n  const [argumentMap, setArgumentMap] = useState({ nodes: [], edges: [] });\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  \r\n  // UI state\r\n  const [activeExpertId, setActiveExpertId] = useState(null);\r\n  const [activeCitation, setActiveCitation] = useState(null);\r\n  const [selectedArgument, setSelectedArgument] = useState(null);\r\n  const [debateControls, setDebateControls] = useState({\r\n    depth: 50,  // 0-100 scale\r\n    technicalLevel: 'medium', // basic, medium, advanced\r\n    emphasis: 'balanced', // ethical, practical, theoretical, balanced\r\n  });\r\n  \r\n  // Initialize analytics when component mounts\r\n  useEffect(() => {\r\n    analyticsService.initAnalytics();\r\n  }, []);\r\n\r\n  /**\r\n   * Start a new debate\r\n   */\r\n  const startDebate = useCallback(async (newTopic, experts, debateFormat = 'standard') => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Generate a new debate\r\n      const result = await debateService.generateDebate(newTopic, experts, debateFormat);\r\n      \r\n      // Update state with new debate data\r\n      setDebateId(result.debateId);\r\n      setTopic(newTopic);\r\n      setFormat(debateFormat);\r\n      setSelectedExperts(experts);\r\n      setTranscript(result.transcript || []);\r\n      setArgumentMap(result.argumentMap || { nodes: [], edges: [] });\r\n      \r\n      // Set the first expert as active\r\n      if (result.transcript && result.transcript.length > 0) {\r\n        setActiveExpertId(result.transcript[0].expertId);\r\n      }\r\n      \r\n      // Track debate start in analytics\r\n      analyticsService.trackDebateStart(newTopic, result.debateId, experts, debateFormat);\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      setError('Failed to start debate: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Ask a follow-up question to a specific expert\r\n   */\r\n  const askFollowUp = useCallback(async (expertId, question) => {\r\n    if (!debateId) return null;\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Send the follow-up question\r\n      const response = await debateService.askFollowUpQuestion(debateId, expertId, question);\r\n      \r\n      // Update transcript with the response\r\n      setTranscript(prev => [...prev, response]);\r\n      setActiveExpertId(expertId);\r\n      \r\n      // Track the interaction\r\n      analyticsService.trackExpertInteraction(debateId, expertId, 'question');\r\n      \r\n      return response;\r\n    } catch (err) {\r\n      setError('Failed to ask follow-up: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [debateId]);\r\n\r\n  /**\r\n   * Challenge an assumption made by an expert\r\n   */\r\n  const challengeAssumption = useCallback(async (argumentId, challenge) => {\r\n    if (!debateId) return null;\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Send the challenge\r\n      const result = await debateService.challengeAssumption(debateId, argumentId, challenge);\r\n      \r\n      // Update transcript with responses\r\n      if (result.responses) {\r\n        setTranscript(prev => [...prev, ...result.responses]);\r\n      }\r\n      \r\n      // Update argument map if provided\r\n      if (result.updatedArgumentMap) {\r\n        setArgumentMap(result.updatedArgumentMap);\r\n      }\r\n      \r\n      // Track the interaction with the first responding expert\r\n      if (result.responses && result.responses.length > 0) {\r\n        analyticsService.trackExpertInteraction(\r\n          debateId, \r\n          result.responses[0].expertId, \r\n          'challenge'\r\n        );\r\n      }\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      setError('Failed to challenge assumption: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [debateId]);\r\n\r\n  /**\r\n   * Request evidence for a specific claim\r\n   */\r\n  const requestEvidence = useCallback(async (argumentId) => {\r\n    if (!debateId) return null;\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Request evidence\r\n      const result = await debateService.requestEvidence(debateId, argumentId);\r\n      \r\n      // Set active citation to show evidence\r\n      setActiveCitation(result);\r\n      \r\n      // Find which expert made this argument\r\n      const expertId = findExpertForArgument(argumentId);\r\n      if (expertId) {\r\n        analyticsService.trackExpertInteraction(debateId, expertId, 'evidence');\r\n      }\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      setError('Failed to request evidence: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [debateId]);\r\n\r\n  /**\r\n   * Find which expert is associated with a given argument\r\n   */\r\n  const findExpertForArgument = useCallback((argumentId) => {\r\n    // Find the node in the argument map\r\n    const node = argumentMap.nodes.find(n => n.id === argumentId);\r\n    return node ? node.expertId : null;\r\n  }, [argumentMap]);\r\n\r\n  /**\r\n   * Generate a steelman version of an argument\r\n   */\r\n  const generateSteelmanArgument = useCallback(async (argumentId) => {\r\n    if (!debateId) return null;\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Request a steelman version\r\n      const result = await debateService.generateSteelmanArgument(debateId, argumentId);\r\n      \r\n      // Create a new message for the steelman response\r\n      const expertId = findExpertForArgument(argumentId);\r\n      if (expertId) {\r\n        const steelmanMessage = {\r\n          expertId,\r\n          content: `Let me strengthen that argument: ${result.steelmanVersion}`,\r\n          timestamp: Date.now(),\r\n          citations: result.additionalEvidence || [],\r\n          isRefinement: true,\r\n        };\r\n        \r\n        // Add to transcript\r\n        setTranscript(prev => [...prev, steelmanMessage]);\r\n        \r\n        // Track the interaction\r\n        analyticsService.trackExpertInteraction(debateId, expertId, 'steelman');\r\n      }\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      setError('Failed to generate steelman argument: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [debateId, findExpertForArgument]);\r\n\r\n  /**\r\n   * Introduce a new consideration to the debate\r\n   */\r\n  const introduceNewConsideration = useCallback(async (consideration) => {\r\n    if (!debateId) return null;\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Introduce the new consideration\r\n      const result = await debateService.introduceNewConsideration(debateId, consideration);\r\n      \r\n      // Update transcript with responses\r\n      if (result.responses) {\r\n        setTranscript(prev => [...prev, ...result.responses]);\r\n      }\r\n      \r\n      // Update argument map if provided\r\n      if (result.updatedArgumentMap) {\r\n        setArgumentMap(result.updatedArgumentMap);\r\n      }\r\n      \r\n      // Track the interaction with all responding experts\r\n      if (result.responses && result.responses.length > 0) {\r\n        result.responses.forEach(response => {\r\n          analyticsService.trackExpertInteraction(\r\n            debateId, \r\n            response.expertId, \r\n            'consideration'\r\n          );\r\n        });\r\n      }\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      setError('Failed to introduce new consideration: ' + err.message);\r\n      return null;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [debateId]);\r\n\r\n  /**\r\n   * Update debate control parameters\r\n   */\r\n  const updateDebateControls = useCallback((controls) => {\r\n    setDebateControls(prev => ({ ...prev, ...controls }));\r\n    \r\n    // Track preference updates\r\n    analyticsService.trackUserPreferences({\r\n      debateControls: { ...debateControls, ...controls },\r\n    });\r\n  }, [debateControls]);\r\n\r\n  /**\r\n   * View a specific citation\r\n   */\r\n  const viewCitation = useCallback((citationId, expertId) => {\r\n    // Find the citation in the transcript\r\n    const citation = transcript.flatMap(message => \r\n      message.citations || []\r\n    ).find(cite => cite.id === citationId);\r\n    \r\n    // Set as active citation\r\n    if (citation) {\r\n      setActiveCitation(citation);\r\n      \r\n      // Track citation exploration\r\n      analyticsService.trackCitationExplored(debateId, citationId, expertId);\r\n    }\r\n  }, [transcript, debateId]);\r\n\r\n  /**\r\n   * Clear active citation\r\n   */\r\n  const clearActiveCitation = useCallback(() => {\r\n    setActiveCitation(null);\r\n  }, []);\r\n\r\n  /**\r\n   * Select an argument in the visualization\r\n   */\r\n  const selectArgument = useCallback((argumentId) => {\r\n    setSelectedArgument(argumentId);\r\n  }, []);\r\n\r\n  /**\r\n   * Reset the debate state\r\n   */\r\n  const resetDebate = useCallback(() => {\r\n    // Track debate completion if there was an active debate\r\n    if (debateId) {\r\n      const duration = Math.floor((Date.now() - transcript[0]?.timestamp || 0) / 1000);\r\n      analyticsService.trackDebateCompletion(debateId, duration, transcript.length);\r\n    }\r\n    \r\n    // Reset all state\r\n    setDebateId(null);\r\n    setTopic('');\r\n    setFormat('standard');\r\n    setSelectedExperts([]);\r\n    setTranscript([]);\r\n    setArgumentMap({ nodes: [], edges: [] });\r\n    setActiveExpertId(null);\r\n    setActiveCitation(null);\r\n    setSelectedArgument(null);\r\n    setError(null);\r\n  }, [debateId, transcript]);\r\n\r\n  // Context value\r\n  const contextValue = {\r\n    // State\r\n    debateId,\r\n    topic,\r\n    format,\r\n    selectedExperts,\r\n    transcript,\r\n    argumentMap,\r\n    loading,\r\n    error,\r\n    activeExpertId,\r\n    activeCitation,\r\n    selectedArgument,\r\n    debateControls,\r\n    \r\n    // Actions\r\n    startDebate,\r\n    askFollowUp,\r\n    challengeAssumption,\r\n    requestEvidence,\r\n    generateSteelmanArgument,\r\n    introduceNewConsideration,\r\n    updateDebateControls,\r\n    viewCitation,\r\n    clearActiveCitation,\r\n    selectArgument,\r\n    resetDebate,\r\n  };\r\n\r\n  return (\r\n    <DebateContext.Provider value={contextValue}>\r\n      {children}\r\n    </DebateContext.Provider>\r\n  );\r\n};\r\n\r\nexport default DebateContext;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}