{"ast":null,"code":"// src/services/analyticsService.js\n\n/**\r\n * Analytics Service\r\n * \r\n * Handles tracking, analysis, and reporting of user interactions\r\n * and system performance metrics for the Socratic Debate Simulator.\r\n */\n\n// This is a mock implementation since the actual service wasn't provided\n\nconst analyticsService = {\n  initAnalytics: () => {\n    console.log('Analytics initialized');\n    // Implementation for initializing analytics would go here\n  },\n  trackDebateStart: (topic, debateId, experts, format) => {\n    console.log('Debate started:', {\n      topic,\n      debateId,\n      experts,\n      format\n    });\n    // Implementation for tracking debate start would go here\n  },\n  trackExpertInteraction: (debateId, expertId, interactionType) => {\n    console.log('Expert interaction:', {\n      debateId,\n      expertId,\n      interactionType\n    });\n    // Implementation for tracking expert interactions would go here\n  },\n  trackUserPreferences: preferences => {\n    console.log('User preferences updated:', preferences);\n    // Implementation for tracking user preferences would go here\n  },\n  trackCitationExplored: (debateId, citationId, expertId) => {\n    console.log('Citation explored:', {\n      debateId,\n      citationId,\n      expertId\n    });\n    // Implementation for tracking citation exploration would go here\n  },\n  trackDebateCompletion: (debateId, duration, messageCount) => {\n    console.log('Debate completed:', {\n      debateId,\n      duration,\n      messageCount\n    });\n    // Implementation for tracking debate completion would go here\n  }\n};\n\n// Local storage keys\nconst STORAGE_KEYS = {\n  USER_PREFERENCES: 'socratic_user_preferences',\n  INTERACTION_HISTORY: 'socratic_interaction_history',\n  SESSION_DATA: 'socratic_session_data'\n};\n\n/**\r\n * Initialize analytics service\r\n * @returns {boolean} Success status\r\n */\nexport const initAnalytics = () => {\n  try {\n    // Initialize session data if it doesn't exist\n    if (!getSessionData()) {\n      const sessionData = {\n        sessionId: generateSessionId(),\n        startTime: Date.now(),\n        deviceInfo: getDeviceInfo(),\n        interactionCount: 0,\n        debatesStarted: 0,\n        topicsExplored: [],\n        expertInteractions: {}\n      };\n      saveSessionData(sessionData);\n    }\n\n    // Log initialization\n    console.log('Analytics service initialized');\n    return true;\n  } catch (error) {\n    console.error('Failed to initialize analytics service:', error);\n    return false;\n  }\n};\n\n/**\r\n * Track debate initiation\r\n * @param {string} topicId - Topic identifier\r\n * @param {string} debateId - Debate identifier\r\n * @param {Array} expertIds - Selected expert IDs\r\n * @param {string} format - Debate format (standard, oxford, socratic)\r\n */\nexport const trackDebateStart = (topicId, debateId, expertIds, format) => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return;\n\n    // Update session data\n    sessionData.debatesStarted += 1;\n\n    // Track new topic if not previously explored\n    if (!sessionData.topicsExplored.includes(topicId)) {\n      sessionData.topicsExplored.push(topicId);\n    }\n\n    // Initialize expert interaction counters\n    expertIds.forEach(expertId => {\n      if (!sessionData.expertInteractions[expertId]) {\n        sessionData.expertInteractions[expertId] = 0;\n      }\n    });\n\n    // Save updated session data\n    saveSessionData(sessionData);\n\n    // Log debate event\n    logEvent('debate_started', {\n      topicId,\n      debateId,\n      expertIds,\n      format,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track debate start:', error);\n  }\n};\n\n/**\r\n * Track user interaction with experts\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} expertId - Expert identifier\r\n * @param {string} interactionType - Type of interaction (question, challenge, etc.)\r\n */\nexport const trackExpertInteraction = (debateId, expertId, interactionType) => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return;\n\n    // Update interaction counts\n    sessionData.interactionCount += 1;\n\n    // Update expert-specific interaction count\n    if (sessionData.expertInteractions[expertId] !== undefined) {\n      sessionData.expertInteractions[expertId] += 1;\n    } else {\n      sessionData.expertInteractions[expertId] = 1;\n    }\n\n    // Save updated session data\n    saveSessionData(sessionData);\n\n    // Log interaction event\n    logEvent('expert_interaction', {\n      debateId,\n      expertId,\n      interactionType,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track expert interaction:', error);\n  }\n};\n\n/**\r\n * Track citation exploration\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} citationId - Citation identifier\r\n * @param {string} expertId - Expert who provided the citation\r\n */\nexport const trackCitationExplored = (debateId, citationId, expertId) => {\n  try {\n    // Log citation event\n    logEvent('citation_explored', {\n      debateId,\n      citationId,\n      expertId,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track citation exploration:', error);\n  }\n};\n\n/**\r\n * Track user preference settings\r\n * @param {Object} preferences - User preference settings\r\n */\nexport const trackUserPreferences = preferences => {\n  try {\n    // Save preferences\n    saveUserPreferences(preferences);\n\n    // Log preferences event\n    logEvent('preferences_updated', {\n      preferences,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track user preferences:', error);\n  }\n};\n\n/**\r\n * Track debate completion\r\n * @param {string} debateId - Debate identifier\r\n * @param {number} duration - Debate duration in seconds\r\n * @param {number} interactionCount - Number of user interactions\r\n */\nexport const trackDebateCompletion = (debateId, duration, interactionCount) => {\n  try {\n    // Log completion event\n    logEvent('debate_completed', {\n      debateId,\n      duration,\n      interactionCount,\n      timestamp: Date.now()\n    });\n  } catch (error) {\n    console.error('Failed to track debate completion:', error);\n  }\n};\n\n/**\r\n * Generate learning insights from debate interaction\r\n * @param {string} debateId - Debate identifier\r\n * @returns {Object} Learning insights data\r\n */\nexport const generateLearningInsights = debateId => {\n  try {\n    const sessionData = getSessionData();\n    if (!sessionData) return null;\n\n    // Get interaction history\n    const interactionHistory = getInteractionHistory();\n\n    // Filter interactions for this debate\n    const debateInteractions = interactionHistory.filter(event => event.data.debateId === debateId);\n\n    // Analyze interaction patterns\n    const expertInteractions = {};\n    const interactionTypes = {};\n    debateInteractions.forEach(event => {\n      if (event.type === 'expert_interaction') {\n        const {\n          expertId,\n          interactionType\n        } = event.data;\n\n        // Count expert interactions\n        expertInteractions[expertId] = (expertInteractions[expertId] || 0) + 1;\n\n        // Count interaction types\n        interactionTypes[interactionType] = (interactionTypes[interactionType] || 0) + 1;\n      }\n    });\n\n    // Generate insights\n    return {\n      totalInteractions: debateInteractions.length,\n      expertEngagement: expertInteractions,\n      interactionTypes,\n      topInteractionType: getTopKey(interactionTypes),\n      mostEngagedExpert: getTopKey(expertInteractions),\n      learningStyle: determineLearningStyle(interactionTypes)\n    };\n  } catch (error) {\n    console.error('Failed to generate learning insights:', error);\n    return null;\n  }\n};\n\n/**\r\n * Save user preferences to local storage\r\n * @param {Object} preferences - User preference settings\r\n */\nconst saveUserPreferences = preferences => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.USER_PREFERENCES, JSON.stringify(preferences));\n  } catch (error) {\n    console.error('Failed to save user preferences:', error);\n  }\n};\n\n/**\r\n * Get user preferences from local storage\r\n * @returns {Object|null} User preferences or null if not found\r\n */\nexport const getUserPreferences = () => {\n  try {\n    const preferences = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);\n    return preferences ? JSON.parse(preferences) : null;\n  } catch (error) {\n    console.error('Failed to get user preferences:', error);\n    return null;\n  }\n};\n\n/**\r\n * Save session data to local storage\r\n * @param {Object} sessionData - Current session data\r\n */\nconst saveSessionData = sessionData => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.SESSION_DATA, JSON.stringify(sessionData));\n  } catch (error) {\n    console.error('Failed to save session data:', error);\n  }\n};\n\n/**\r\n * Get session data from local storage\r\n * @returns {Object|null} Session data or null if not found\r\n */\nconst getSessionData = () => {\n  try {\n    const sessionData = localStorage.getItem(STORAGE_KEYS.SESSION_DATA);\n    return sessionData ? JSON.parse(sessionData) : null;\n  } catch (error) {\n    console.error('Failed to get session data:', error);\n    return null;\n  }\n};\n\n/**\r\n * Log event to interaction history\r\n * @param {string} type - Event type\r\n * @param {Object} data - Event data\r\n */\nconst logEvent = (type, data) => {\n  try {\n    // Get existing history\n    const history = getInteractionHistory();\n\n    // Add new event\n    history.push({\n      type,\n      data,\n      timestamp: Date.now()\n    });\n\n    // Limit history size (keep last 1000 events)\n    if (history.length > 1000) {\n      history.shift();\n    }\n\n    // Save updated history\n    localStorage.setItem(STORAGE_KEYS.INTERACTION_HISTORY, JSON.stringify(history));\n  } catch (error) {\n    console.error('Failed to log event:', error);\n  }\n};\n\n/**\r\n * Get interaction history from local storage\r\n * @returns {Array} Interaction event history\r\n */\nconst getInteractionHistory = () => {\n  try {\n    const history = localStorage.getItem(STORAGE_KEYS.INTERACTION_HISTORY);\n    return history ? JSON.parse(history) : [];\n  } catch (error) {\n    console.error('Failed to get interaction history:', error);\n    return [];\n  }\n};\n\n/**\r\n * Generate unique session ID\r\n * @returns {string} Session identifier\r\n */\nconst generateSessionId = () => {\n  return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);\n};\n\n/**\r\n * Get device information\r\n * @returns {Object} Device information\r\n */\nconst getDeviceInfo = () => {\n  return {\n    userAgent: navigator.userAgent,\n    language: navigator.language,\n    platform: navigator.platform,\n    screenWidth: window.screen.width,\n    screenHeight: window.screen.height\n  };\n};\n\n/**\r\n * Get key with highest value from object\r\n * @param {Object} obj - Object with numeric values\r\n * @returns {string|null} Key with highest value or null if empty\r\n */\nconst getTopKey = obj => {\n  if (!obj || Object.keys(obj).length === 0) return null;\n  return Object.entries(obj).reduce((top, [key, value]) => value > top.value ? {\n    key,\n    value\n  } : top, {\n    key: Object.keys(obj)[0],\n    value: obj[Object.keys(obj)[0]]\n  }).key;\n};\n\n/**\r\n * Determine user learning style based on interaction patterns\r\n * @param {Object} interactionTypes - Counts of different interaction types\r\n * @returns {string} Learning style descriptor\r\n */\nconst determineLearningStyle = interactionTypes => {\n  // Count different categories of interactions\n  const questionCount = interactionTypes.question || 0;\n  const challengeCount = interactionTypes.challenge || 0;\n  const evidenceCount = interactionTypes.evidence || 0;\n\n  // Determine primary learning style\n  if (questionCount > challengeCount && questionCount > evidenceCount) {\n    return 'Inquisitive Explorer';\n  } else if (challengeCount > questionCount && challengeCount > evidenceCount) {\n    return 'Critical Thinker';\n  } else if (evidenceCount > questionCount && evidenceCount > challengeCount) {\n    return 'Evidence-Based Analyzer';\n  } else {\n    return 'Balanced Learner';\n  }\n};\n\n/**\r\n * Clear all analytics data\r\n * @returns {boolean} Success status\r\n */\nexport const clearAnalyticsData = () => {\n  try {\n    localStorage.removeItem(STORAGE_KEYS.USER_PREFERENCES);\n    localStorage.removeItem(STORAGE_KEYS.INTERACTION_HISTORY);\n    localStorage.removeItem(STORAGE_KEYS.SESSION_DATA);\n    return true;\n  } catch (error) {\n    console.error('Failed to clear analytics data:', error);\n    return false;\n  }\n};\nexport default {\n  initAnalytics,\n  trackDebateStart,\n  trackExpertInteraction,\n  trackCitationExplored,\n  trackUserPreferences,\n  trackDebateCompletion,\n  generateLearningInsights,\n  getUserPreferences,\n  clearAnalyticsData,\n  saveUserPreferences,\n  analyticsService\n};","map":{"version":3,"names":["analyticsService","initAnalytics","console","log","trackDebateStart","topic","debateId","experts","format","trackExpertInteraction","expertId","interactionType","trackUserPreferences","preferences","trackCitationExplored","citationId","trackDebateCompletion","duration","messageCount","STORAGE_KEYS","USER_PREFERENCES","INTERACTION_HISTORY","SESSION_DATA","getSessionData","sessionData","sessionId","generateSessionId","startTime","Date","now","deviceInfo","getDeviceInfo","interactionCount","debatesStarted","topicsExplored","expertInteractions","saveSessionData","error","topicId","expertIds","includes","push","forEach","logEvent","timestamp","undefined","saveUserPreferences","generateLearningInsights","interactionHistory","getInteractionHistory","debateInteractions","filter","event","data","interactionTypes","type","totalInteractions","length","expertEngagement","topInteractionType","getTopKey","mostEngagedExpert","learningStyle","determineLearningStyle","localStorage","setItem","JSON","stringify","getUserPreferences","getItem","parse","history","shift","Math","random","toString","substring","userAgent","navigator","language","platform","screenWidth","window","screen","width","screenHeight","height","obj","Object","keys","entries","reduce","top","key","value","questionCount","question","challengeCount","challenge","evidenceCount","evidence","clearAnalyticsData","removeItem"],"sources":["C:/Users/HAJAR/socratic-debate-simulator/src/services/analyticsService.js"],"sourcesContent":["// src/services/analyticsService.js\r\n\r\n/**\r\n * Analytics Service\r\n * \r\n * Handles tracking, analysis, and reporting of user interactions\r\n * and system performance metrics for the Socratic Debate Simulator.\r\n */\r\n\r\n// This is a mock implementation since the actual service wasn't provided\r\n\r\nconst analyticsService = {\r\n  initAnalytics: () => {\r\n    console.log('Analytics initialized');\r\n    // Implementation for initializing analytics would go here\r\n  },\r\n  \r\n  trackDebateStart: (topic, debateId, experts, format) => {\r\n    console.log('Debate started:', { topic, debateId, experts, format });\r\n    // Implementation for tracking debate start would go here\r\n  },\r\n  \r\n  trackExpertInteraction: (debateId, expertId, interactionType) => {\r\n    console.log('Expert interaction:', { debateId, expertId, interactionType });\r\n    // Implementation for tracking expert interactions would go here\r\n  },\r\n  \r\n  trackUserPreferences: (preferences) => {\r\n    console.log('User preferences updated:', preferences);\r\n    // Implementation for tracking user preferences would go here\r\n  },\r\n  \r\n  trackCitationExplored: (debateId, citationId, expertId) => {\r\n    console.log('Citation explored:', { debateId, citationId, expertId });\r\n    // Implementation for tracking citation exploration would go here\r\n  },\r\n  \r\n  trackDebateCompletion: (debateId, duration, messageCount) => {\r\n    console.log('Debate completed:', { debateId, duration, messageCount });\r\n    // Implementation for tracking debate completion would go here\r\n  }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Local storage keys\r\nconst STORAGE_KEYS = {\r\n  USER_PREFERENCES: 'socratic_user_preferences',\r\n  INTERACTION_HISTORY: 'socratic_interaction_history',\r\n  SESSION_DATA: 'socratic_session_data',\r\n};\r\n\r\n/**\r\n * Initialize analytics service\r\n * @returns {boolean} Success status\r\n */\r\nexport const initAnalytics = () => {\r\n  try {\r\n    // Initialize session data if it doesn't exist\r\n    if (!getSessionData()) {\r\n      const sessionData = {\r\n        sessionId: generateSessionId(),\r\n        startTime: Date.now(),\r\n        deviceInfo: getDeviceInfo(),\r\n        interactionCount: 0,\r\n        debatesStarted: 0,\r\n        topicsExplored: [],\r\n        expertInteractions: {},\r\n      };\r\n      \r\n      saveSessionData(sessionData);\r\n    }\r\n    \r\n    // Log initialization\r\n    console.log('Analytics service initialized');\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Failed to initialize analytics service:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Track debate initiation\r\n * @param {string} topicId - Topic identifier\r\n * @param {string} debateId - Debate identifier\r\n * @param {Array} expertIds - Selected expert IDs\r\n * @param {string} format - Debate format (standard, oxford, socratic)\r\n */\r\nexport const trackDebateStart = (topicId, debateId, expertIds, format) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return;\r\n    \r\n    // Update session data\r\n    sessionData.debatesStarted += 1;\r\n    \r\n    // Track new topic if not previously explored\r\n    if (!sessionData.topicsExplored.includes(topicId)) {\r\n      sessionData.topicsExplored.push(topicId);\r\n    }\r\n    \r\n    // Initialize expert interaction counters\r\n    expertIds.forEach(expertId => {\r\n      if (!sessionData.expertInteractions[expertId]) {\r\n        sessionData.expertInteractions[expertId] = 0;\r\n      }\r\n    });\r\n    \r\n    // Save updated session data\r\n    saveSessionData(sessionData);\r\n    \r\n    // Log debate event\r\n    logEvent('debate_started', {\r\n      topicId,\r\n      debateId,\r\n      expertIds,\r\n      format,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track debate start:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track user interaction with experts\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} expertId - Expert identifier\r\n * @param {string} interactionType - Type of interaction (question, challenge, etc.)\r\n */\r\nexport const trackExpertInteraction = (debateId, expertId, interactionType) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return;\r\n    \r\n    // Update interaction counts\r\n    sessionData.interactionCount += 1;\r\n    \r\n    // Update expert-specific interaction count\r\n    if (sessionData.expertInteractions[expertId] !== undefined) {\r\n      sessionData.expertInteractions[expertId] += 1;\r\n    } else {\r\n      sessionData.expertInteractions[expertId] = 1;\r\n    }\r\n    \r\n    // Save updated session data\r\n    saveSessionData(sessionData);\r\n    \r\n    // Log interaction event\r\n    logEvent('expert_interaction', {\r\n      debateId,\r\n      expertId,\r\n      interactionType,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track expert interaction:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track citation exploration\r\n * @param {string} debateId - Debate identifier\r\n * @param {string} citationId - Citation identifier\r\n * @param {string} expertId - Expert who provided the citation\r\n */\r\nexport const trackCitationExplored = (debateId, citationId, expertId) => {\r\n  try {\r\n    // Log citation event\r\n    logEvent('citation_explored', {\r\n      debateId,\r\n      citationId,\r\n      expertId,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track citation exploration:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track user preference settings\r\n * @param {Object} preferences - User preference settings\r\n */\r\nexport const trackUserPreferences = (preferences) => {\r\n  try {\r\n    // Save preferences\r\n    saveUserPreferences(preferences);\r\n    \r\n    // Log preferences event\r\n    logEvent('preferences_updated', {\r\n      preferences,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track user preferences:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Track debate completion\r\n * @param {string} debateId - Debate identifier\r\n * @param {number} duration - Debate duration in seconds\r\n * @param {number} interactionCount - Number of user interactions\r\n */\r\nexport const trackDebateCompletion = (debateId, duration, interactionCount) => {\r\n  try {\r\n    // Log completion event\r\n    logEvent('debate_completed', {\r\n      debateId,\r\n      duration,\r\n      interactionCount,\r\n      timestamp: Date.now(),\r\n    });\r\n  } catch (error) {\r\n    console.error('Failed to track debate completion:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Generate learning insights from debate interaction\r\n * @param {string} debateId - Debate identifier\r\n * @returns {Object} Learning insights data\r\n */\r\nexport const generateLearningInsights = (debateId) => {\r\n  try {\r\n    const sessionData = getSessionData();\r\n    if (!sessionData) return null;\r\n    \r\n    // Get interaction history\r\n    const interactionHistory = getInteractionHistory();\r\n    \r\n    // Filter interactions for this debate\r\n    const debateInteractions = interactionHistory.filter(\r\n      event => event.data.debateId === debateId\r\n    );\r\n    \r\n    // Analyze interaction patterns\r\n    const expertInteractions = {};\r\n    const interactionTypes = {};\r\n    \r\n    debateInteractions.forEach(event => {\r\n      if (event.type === 'expert_interaction') {\r\n        const { expertId, interactionType } = event.data;\r\n        \r\n        // Count expert interactions\r\n        expertInteractions[expertId] = (expertInteractions[expertId] || 0) + 1;\r\n        \r\n        // Count interaction types\r\n        interactionTypes[interactionType] = (interactionTypes[interactionType] || 0) + 1;\r\n      }\r\n    });\r\n    \r\n    // Generate insights\r\n    return {\r\n      totalInteractions: debateInteractions.length,\r\n      expertEngagement: expertInteractions,\r\n      interactionTypes,\r\n      topInteractionType: getTopKey(interactionTypes),\r\n      mostEngagedExpert: getTopKey(expertInteractions),\r\n      learningStyle: determineLearningStyle(interactionTypes),\r\n    };\r\n  } catch (error) {\r\n    console.error('Failed to generate learning insights:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Save user preferences to local storage\r\n * @param {Object} preferences - User preference settings\r\n */\r\nconst saveUserPreferences = (preferences) => {\r\n  try {\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.USER_PREFERENCES,\r\n      JSON.stringify(preferences)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to save user preferences:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get user preferences from local storage\r\n * @returns {Object|null} User preferences or null if not found\r\n */\r\nexport const getUserPreferences = () => {\r\n  try {\r\n    const preferences = localStorage.getItem(STORAGE_KEYS.USER_PREFERENCES);\r\n    return preferences ? JSON.parse(preferences) : null;\r\n  } catch (error) {\r\n    console.error('Failed to get user preferences:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Save session data to local storage\r\n * @param {Object} sessionData - Current session data\r\n */\r\nconst saveSessionData = (sessionData) => {\r\n  try {\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.SESSION_DATA,\r\n      JSON.stringify(sessionData)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to save session data:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get session data from local storage\r\n * @returns {Object|null} Session data or null if not found\r\n */\r\nconst getSessionData = () => {\r\n  try {\r\n    const sessionData = localStorage.getItem(STORAGE_KEYS.SESSION_DATA);\r\n    return sessionData ? JSON.parse(sessionData) : null;\r\n  } catch (error) {\r\n    console.error('Failed to get session data:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Log event to interaction history\r\n * @param {string} type - Event type\r\n * @param {Object} data - Event data\r\n */\r\nconst logEvent = (type, data) => {\r\n  try {\r\n    // Get existing history\r\n    const history = getInteractionHistory();\r\n    \r\n    // Add new event\r\n    history.push({\r\n      type,\r\n      data,\r\n      timestamp: Date.now(),\r\n    });\r\n    \r\n    // Limit history size (keep last 1000 events)\r\n    if (history.length > 1000) {\r\n      history.shift();\r\n    }\r\n    \r\n    // Save updated history\r\n    localStorage.setItem(\r\n      STORAGE_KEYS.INTERACTION_HISTORY,\r\n      JSON.stringify(history)\r\n    );\r\n  } catch (error) {\r\n    console.error('Failed to log event:', error);\r\n  }\r\n};\r\n\r\n/**\r\n * Get interaction history from local storage\r\n * @returns {Array} Interaction event history\r\n */\r\nconst getInteractionHistory = () => {\r\n  try {\r\n    const history = localStorage.getItem(STORAGE_KEYS.INTERACTION_HISTORY);\r\n    return history ? JSON.parse(history) : [];\r\n  } catch (error) {\r\n    console.error('Failed to get interaction history:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Generate unique session ID\r\n * @returns {string} Session identifier\r\n */\r\nconst generateSessionId = () => {\r\n  return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);\r\n};\r\n\r\n/**\r\n * Get device information\r\n * @returns {Object} Device information\r\n */\r\nconst getDeviceInfo = () => {\r\n  return {\r\n    userAgent: navigator.userAgent,\r\n    language: navigator.language,\r\n    platform: navigator.platform,\r\n    screenWidth: window.screen.width,\r\n    screenHeight: window.screen.height,\r\n  };\r\n};\r\n\r\n/**\r\n * Get key with highest value from object\r\n * @param {Object} obj - Object with numeric values\r\n * @returns {string|null} Key with highest value or null if empty\r\n */\r\nconst getTopKey = (obj) => {\r\n  if (!obj || Object.keys(obj).length === 0) return null;\r\n  \r\n  return Object.entries(obj).reduce(\r\n    (top, [key, value]) => (value > top.value ? { key, value } : top),\r\n    { key: Object.keys(obj)[0], value: obj[Object.keys(obj)[0]] }\r\n  ).key;\r\n};\r\n\r\n/**\r\n * Determine user learning style based on interaction patterns\r\n * @param {Object} interactionTypes - Counts of different interaction types\r\n * @returns {string} Learning style descriptor\r\n */\r\nconst determineLearningStyle = (interactionTypes) => {\r\n  // Count different categories of interactions\r\n  const questionCount = interactionTypes.question || 0;\r\n  const challengeCount = interactionTypes.challenge || 0;\r\n  const evidenceCount = interactionTypes.evidence || 0;\r\n  \r\n  // Determine primary learning style\r\n  if (questionCount > challengeCount && questionCount > evidenceCount) {\r\n    return 'Inquisitive Explorer';\r\n  } else if (challengeCount > questionCount && challengeCount > evidenceCount) {\r\n    return 'Critical Thinker';\r\n  } else if (evidenceCount > questionCount && evidenceCount > challengeCount) {\r\n    return 'Evidence-Based Analyzer';\r\n  } else {\r\n    return 'Balanced Learner';\r\n  }\r\n};\r\n\r\n/**\r\n * Clear all analytics data\r\n * @returns {boolean} Success status\r\n */\r\nexport const clearAnalyticsData = () => {\r\n  try {\r\n    localStorage.removeItem(STORAGE_KEYS.USER_PREFERENCES);\r\n    localStorage.removeItem(STORAGE_KEYS.INTERACTION_HISTORY);\r\n    localStorage.removeItem(STORAGE_KEYS.SESSION_DATA);\r\n    return true;\r\n  } catch (error) {\r\n    console.error('Failed to clear analytics data:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\nexport default {\r\n  initAnalytics,\r\n  trackDebateStart,\r\n  trackExpertInteraction,\r\n  trackCitationExplored,\r\n  trackUserPreferences,\r\n  trackDebateCompletion,\r\n  generateLearningInsights,\r\n  getUserPreferences,\r\n  clearAnalyticsData,\r\n  saveUserPreferences,\r\n  analyticsService\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}